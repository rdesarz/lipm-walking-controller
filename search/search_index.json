{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Biped Walking Controller","text":"<p>This project presents an open-source Python implementation of the Linear Inverted Pendulum Model (LIPM) walking pattern  generator based on preview control of the Zero-Moment Point (ZMP), following the formulation introduced  by Kajita et al., \u201cBiped Walking Pattern Generation by Using Preview Control of the Zero-Moment Point,\u201d ICRA 2003.</p> <p>The animation below shows the controller in action in a Pybullet simulation:</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>The objective is to reproduce and analyze the ZMP preview control pipeline:</p> <ul> <li>Model the robot\u2019s CoM using the 3D LIPM</li> <li>Compute optimal CoM trajectories given a reference ZMP sequence using preview control </li> <li>Generate corresponding foot trajectories</li> <li>Apply inverse kinematics to produce consistent joint motions</li> <li>Apply computed joint positions to the simulated robot in Pybullet</li> </ul> <p>The different steps are represented by the figure below:</p> <pre><code>flowchart TD\n    zmp_ref[\"ZMP reference generation\"]\n    zmp_preview[\"ZMP Preview Controller\"] \n    foot[\"Foot trajectory generation\"]\n    foot[\"Foot trajectory generation\"]\n    inverse_kin[\"Inverse kinematics\"]\n    sim[\"Simulator\"]\n    zmp_ref --&gt;|\"ZMP trajectory\"| zmp_preview --&gt;|\"CoM trajectory\"| foot --&gt;|\"Foot trajectory\"| inverse_kin --&gt;|\"Joints position\"| sim</code></pre> <p>The implementation prioritizes simplicity and experimental reproducibility, making it suitable for education purpose. It relies on Pinocchio to handle the kinematics of the robot and PyBullet for physics simulation.</p>"},{"location":"foot/","title":"Foot trajectory generation","text":""},{"location":"foot/#swing-foot-trajectory-generation","title":"Swing foot trajectory generation","text":"<p>Walking is organized into fixed-duration phases: Single Support (SS) and Double Support (DS). In Single Support, one foot is the  swing foot and the other is the stance foot. In Double Support both feet are in contact and no swing foot exists. The timing of each  phase is related to the trajectory of the ZMP. During Single Support phase, the ZMP position is maintained over the stance foot. During Double Support phase, the ZMP position moves from a foot to another. Currently, there are two approaches can be used to generate the swing foot trajectory: * The first one is to follow a sinusoidal time law along the world x-axis from \\(x_0\\) to \\(x_1\\)  over duration \\(T_{SS}\\).  * The second, default option uses a minimum-jerk B\u00e9zier curve whose velocity and acceleration are aligned with the ground normal. This ensures smooth foot motion. The curve parameters are set so that its peak reaches the desired maximum height. </p> <p>The foot orientation is kept constant with yaw=0;  the sole remains parallel to the floor. All phase durations are configurable.</p> <p>The figure below shows the generated trajectory for both foot with a height of 20cm:</p> <p> </p>"},{"location":"foot/#example","title":"Example","text":"<p>You can reproduce the example displayed on the figure by launching the script <code>example_2_feet_motion.py</code>. We  recommend you to use Docker as explained in the installation part:</p> <pre><code>xhost +local:root\ndocker run --rm -it \\\n  --env DISPLAY \\\n  -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\\n  --device /dev/dri:/dev/dri \\\n  ghcr.io/rdesarz/biped-walking-controller \\\n  python examples/example_2_feet_motion.py \n</code></pre> <p>The parameters used in this script are the following:</p> <pre><code>dt = 0.005  # Delta of time of the model simulation\nt_ss = 0.7  # Single support phase time window\nt_ds = 0.8  # Double support phase time window\nt_init = 2.0  # Initialization phase (transition from still position to first step)\nt_end = 2.0 # Final phase (transition from walking to standstill position)\nlf_initial_pose = np.array([0.0, 0.1, 0.0]) # Initial position of the left foot\nrf_initial_pose = np.array([0.0, -0.1, 0.0]) # Initial position of the right foot\nn_steps = 5 # Number of steps\nl_stride = 0.3 # Length of the stride\nmax_height_foot = 0.2 # Maximal height of the foot during motion of the swing foot\n</code></pre>"},{"location":"foot/#code-api","title":"Code API","text":"<p>Footstep geometry and trajectories utilities.</p> <p>Provides:</p> <ul> <li>Polygon operations to compute single/double-support regions.</li> <li>ZMP clamp to the current support polygon.</li> <li>Deterministic swing-foot trajectories and step poses.</li> </ul>"},{"location":"foot/#biped_walking_controller.foot.BezierCurveFootPathGenerator","title":"BezierCurveFootPathGenerator","text":"<pre><code>BezierCurveFootPathGenerator(foot_height)\n</code></pre> <p>Swing-foot path generator using a quintic B\u00e9zier with zero vel/acc at endpoints.</p> <p>This generator fixes the first three control points at the start pose and the last three at the end pose, then sets the vertical components of the interior points to reach a prescribed apex height. The vertical \u201cshape\u201d parameter <code>alpha</code> is searched once at construction, then reused per call.</p> <p>Parameters:</p> Name Type Description Default <code>foot_height</code> <code>float</code> <p>Desired apex height of the swing foot above the line segment connecting start and end poses.</p> required <p>Attributes:</p> Name Type Description <code>alpha</code> <code>float</code> <p>Internal vertical shaping parameter calibrated so that the curve height at <code>s=0.5</code> equals <code>foot_height</code>.</p> Notes <ul> <li>The constructor performs a simple grid search over <code>alpha</code> in   <code>[0, 2*foot_height]</code> to match the apex within <code>1e-3</code>.</li> <li>Endpoints have zero velocity and acceleration due to repeated control   points: <code>P0=P1=P2</code> and <code>P3=P4=P5</code>.</li> </ul>"},{"location":"foot/#biped_walking_controller.foot.SinusoidFootPathGenerator","title":"SinusoidFootPathGenerator","text":"<pre><code>SinusoidFootPathGenerator(foot_height)\n</code></pre> <p>Swing-foot path generator with sinusoidal vertical profile.</p> <p>The horizontal motion is linear from start to end along x, with y held constant at the start value. The vertical component follows:     z(s) = foot_height * sin(pi * s)</p> <p>Parameters:</p> Name Type Description Default <code>foot_height</code> <code>float</code> <p>Maximum height at mid-swing.</p> required Notes <p>This profile is C1 at the endpoints (zero velocity) but not C2 like the B\u00e9zier construction. Use the B\u00e9zier for smoother contact transitions.</p>"},{"location":"foot/#biped_walking_controller.foot.bezier_quintic","title":"bezier_quintic","text":"<pre><code>bezier_quintic(P, s)\n</code></pre> <p>Evaluate a quintic (degree-5) B\u00e9zier curve at parameter values <code>s</code>.</p> <p>A quintic B\u00e9zier curve is:     B(s) = \u03a3_{i=0..5} C(5,i) (1-s)^{5-i} s^i P_i</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>ndarray</code> <p>Control points of shape <code>(6, 3)</code>. Rows are <code>P0..P5</code>. Columns are Cartesian coordinates <code>[x, y, z]</code>.</p> required <code>s</code> <code>ndarray</code> <p>1D array of parameter values in <code>[0, 1]</code> of shape <code>(N,)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Curve samples of shape <code>(N, 3)</code>.</p> Notes <p>With <code>P0=P1=P2</code> and <code>P3=P4=P5</code>, the curve has zero velocity and acceleration at both ends, which is the typical \u201cminimum-jerk\u201d boundary condition used for swing-foot profiles.</p>"},{"location":"foot/#biped_walking_controller.foot.compute_feet_trajectories","title":"compute_feet_trajectories","text":"<pre><code>compute_feet_trajectories(rf_initial_pose, lf_initial_pose, n_steps, steps_pose, t_ss, t_ds, t_init, t_final, dt, traj_generator=BezierCurveFootPathGenerator(foot_height=0.1))\n</code></pre> <p>Generate swing trajectories and step poses for alternating feet.</p> Scenario <p>Start with a DS phase of duration <code>t_init</code> to shift CoM. Then for <code>n_steps</code>, alternate SS (duration <code>t_ss</code>) and DS (duration <code>t_ds</code>) with forward stride <code>l_stride</code>. Finish with one SS to align both feet, then a final DS of duration <code>t_final</code> to center CoM.</p> <p>Parameters:</p> Name Type Description Default <code>rf_initial_pose</code> <code>(array - like, shape(3))</code> <p>Initial right foot pose proxy [x, y, z].</p> required <code>lf_initial_pose</code> <code>(array - like, shape(3))</code> <p>Initial left foot pose proxy [x, y, z].</p> required <code>n_steps</code> <code>int</code> <p>Number of forward steps.</p> required <code>t_ss</code> <code>float</code> <p>Single-support duration per step.</p> required <code>t_ds</code> <code>float</code> <p>Double-support duration between steps.</p> required <code>t_init</code> <code>float</code> <p>Initial DS duration before stepping.</p> required <code>t_end</code> <code>float</code> <p>Final DS duration to center the CoM.</p> required <code>l_stride</code> <code>float</code> <p>Step length along +x for each new foothold.</p> required <code>dt</code> <code>float</code> <p>Time discretization step.</p> required <code>max_height_foot</code> <code>float</code> <p>Peak swing height for the swinging foot.</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>(ndarray, shape(N))</code> <p>Time samples.</p> <code>lf_path</code> <code>(ndarray, shape(N, 3))</code> <p>Left foot trajectory [x, y, z].</p> <code>rf_path</code> <code>(ndarray, shape(N, 3))</code> <p>Right foot trajectory [x, y, z].</p> <code>steps_pose</code> <code>(ndarray, shape(n_steps + 2, 2))</code> <p>Planned foothold XY positions. Last row mirrors penultimate y to align feet.</p> <code>phases</code> <code>(ndarray, shape(N))</code> <p>Phase flag over time: -1 for left swing, +1 for right swing, 1 during right-stance, -1 during left-stance, unchanged during DS.</p> Notes <ul> <li>Swing z uses a half-sine profile with peak <code>max_height_foot</code>.</li> <li>X is linearly interpolated during SS, then held constant until the next step.</li> <li>Y remains fixed to the initial lateral offsets.</li> </ul>"},{"location":"foot/#biped_walking_controller.foot.clamp_to_polygon","title":"clamp_to_polygon","text":"<pre><code>clamp_to_polygon(pnt, poly)\n</code></pre> <p>Project a 2D point to the closest location inside a polygon.</p> <p>Parameters:</p> Name Type Description Default <code>pnt</code> <code>(ndarray, shape(2))</code> <p>Input point [x, y].</p> required <code>poly</code> <code>Polygon</code> <p>Support polygon in world coordinates.</p> required <p>Returns:</p> Type Description <code>(ndarray, shape(2))</code> <p>Point inside <code>poly</code>. Equals <code>pnt</code> if already inside.</p> Notes <p>Uses the nearest point on the polygon exterior if outside.</p>"},{"location":"foot/#biped_walking_controller.foot.compute_double_support_polygon","title":"compute_double_support_polygon","text":"<pre><code>compute_double_support_polygon(foot_pose_a, foot_pose_b, foot_shape)\n</code></pre> <p>Compute the convex support region for double support.</p> <p>Parameters:</p> Name Type Description Default <code>foot_pose_a</code> <code>(array - like, shape(2) or (3,))</code> <p>World pose proxy for foot A: uses [x, y].</p> required <code>foot_pose_b</code> <code>(array - like, shape(2) or (3,))</code> <p>World pose proxy for foot B: uses [x, y].</p> required <code>foot_shape</code> <code>Polygon</code> <p>Foot contact shape in the foot frame (centered).</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>Convex hull of the union of both translated foot polygons.</p>"},{"location":"foot/#biped_walking_controller.foot.compute_single_support_polygon","title":"compute_single_support_polygon","text":"<pre><code>compute_single_support_polygon(foot_pose, foot_shape)\n</code></pre> <p>Compute the support region for single support.</p> <p>Parameters:</p> Name Type Description Default <code>foot_pose</code> <code>(array - like, shape(2) or (3,))</code> <p>World pose proxy for the stance foot: uses [x, y].</p> required <code>foot_shape</code> <code>Polygon</code> <p>Foot contact shape in the foot frame (centered).</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>Translated foot polygon in world coordinates.</p>"},{"location":"foot/#biped_walking_controller.foot.get_active_polygon","title":"get_active_polygon","text":"<pre><code>get_active_polygon(t, steps_pose, t_ss, t_ds, foot_shape)\n</code></pre> <p>Select the active support polygon at time <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Elapsed time since start.</p> required <code>steps_pose</code> <code>(array - like, shape(K, 2))</code> <p>Footstep sequence in world XY. Index 0 is the first stance (right or left).</p> required <code>t_ss</code> <code>float</code> <p>Single-support duration per step.</p> required <code>t_ds</code> <code>float</code> <p>Double-support duration between steps.</p> required <code>foot_shape</code> <code>Polygon</code> <p>Foot contact shape in the foot frame (centered).</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>Single- or double-support polygon active at time <code>t</code>.</p> Notes <ul> <li>Step period t_step = t_ss + t_ds.</li> <li>For the last period, returns single support on the last foot.</li> </ul>"},{"location":"foot/#biped_walking_controller.foot.compute_swing_foot_pose","title":"compute_swing_foot_pose","text":"<pre><code>compute_swing_foot_pose(t_state, params, step_start, step_target, touchdown_extension_vel, path_generator)\n</code></pre> <p>Compute swing foot pose for current state time with late touchdown extension.</p> <ul> <li>For t_state in [0, t_ss]: nominal min-jerk swing between step_start and step_target.</li> <li>For t_state &gt; t_ss and no contact: keep moving the commanded foot down   below the nominal ground height at constant velocity.   The physics/contact solver will clamp penetration.</li> <li>As soon as contact_force &gt; force_threshold: freeze at step_target.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>Docker is recommended to run the examples. You simply need to download the docker image associated with the project:</p> <pre><code>docker pull ghcr.io/rdesarz/biped-walking-controller/biped-walking-controller:latest\n</code></pre> <p>You can then run several examples described in each section:</p> <ul> <li>Example 1: preview controller</li> <li>Example 2: foot trajectory generation</li> <li>Example 3: inverse kinematics</li> <li>Example 4: preview controller</li> </ul>"},{"location":"inverse_kinematics/","title":"Differential Inverse Kinematics","text":""},{"location":"inverse_kinematics/#introduction","title":"Introduction","text":"<p>In the context of this project, the goal of the inverse kinematics task is to compute joint velocities to track the desired position of the Center of Mass and foot poses. Each of this goal is called a task. Walking requires several tasks to be handled at the same time:</p> <ul> <li>Keeping the stand foot exactly at a desired 6D pose</li> <li>Tracking the swing foot trajectory</li> <li>Tracking the CoM trajectory</li> <li>Maintaining the torso straight (postural task)</li> <li>Locking some joints as the LIPM model relies on some assumptions on the upper body restrained motion.</li> <li>Constraints due to the joints properties (position and/or velocity limits)</li> </ul> <p>Those tasks might be concurrent. Therefore, the inverse kinematics is well-suited to be seen as an optimization problem with tasks being either a cost to reduce or a constraint to fulfill. A way to solve this is by using a hierarchical Quadratic Program where each task is assigned with a priority (tracking the CoM is more important that postural task for instance). In practice it is hard to find an open-source solver for this kind of optimization problem. Therefore it is modelled as a QP with different weights for each task. A task with high priority will have a higher weight than a low priority task. This is the approach used for instance by the pink library from which this part is inspired.</p>"},{"location":"inverse_kinematics/#kinematic-task","title":"Kinematic task","text":"<p>The goal of a task is to reduce the error (residual) between the desired pose and the actual pose of a frame on the robot. A detailed explanation on how to compute this error for a pose and how to define it as an optimization problem is described in this article.</p>"},{"location":"inverse_kinematics/#tasks","title":"Tasks","text":"<p>We detail here each specific task that we need to fulfill when solving the inverse kinematics problem. For the implementation,  we rely on the Pinocchio library to compute Jacobian and CoM position.</p>"},{"location":"inverse_kinematics/#1-fixed-stance-foot","title":"1. Fixed (Stance) Foot","text":"<p>The stance foot is a hard equality constraint in the QP:</p> \\[ J_{\\text{ff}}\\, \\Delta q = e_{\\text{ff}} \\] <p>where \\(J_{\\text{ff}}\\) is the Jacobian of the fixed foot kinematic task, \\(\\Delta q\\) the joint-space increment, and \\(e_{\\text{ff}}\\) the pose task residual.</p> <p>This constraint ensures the stance foot remains fixed in the world frame. It enforces a no-slip contact at velocity level.</p>"},{"location":"inverse_kinematics/#2-swing-moving-foot","title":"2. Swing (Moving) Foot","text":"<p>Residual and Jacobian \\(e_{mf}, J_{mf}\\) enter the cost as a weighted least squares term, allowing the swing foot to track its desired trajectory.</p>"},{"location":"inverse_kinematics/#3-torso-orientation","title":"3. Torso Orientation","text":"<p>We want to maintain the torso orientation. We select only the angular part of the Jacobian and residual with the matrix <code>S = [0, I]</code>:</p> \\[ e_{\\text{torso}} = S\\, e_{\\text{torso6}}, \\quad J_{\\text{torso}} = S\\, J_{\\text{torso6}}. \\] <p>This aligns the torso without constraining its position.</p>"},{"location":"inverse_kinematics/#4-center-of-mass","title":"4. Center of Mass","text":"<p>The center of mass is only constrained by its position. This is modelled as a cost in the optimization problem. The  jacobian \\(J_{\\text{com}}\\) is the jacobian of the center of mass. The residual is defined below:</p> \\[ e_{\\text{com}} = (x_{\\text{com}}^{\\star} - x_{\\text{com}}), \\quad \\] <p>This task pulls the CoM toward the desired position.</p>"},{"location":"inverse_kinematics/#optimization-problem","title":"Optimization Problem","text":"<p>We want to solve for \\(\\Delta q\\) the QP:</p> \\[\\begin{equation} \\begin{aligned} \\min_{\\Delta q}\\quad &amp; \\tfrac{1}{2}\\,\\Delta q^\\top H \\Delta q + g^\\top \\Delta q \\\\ \\text{s.t.}\\quad &amp; A \\Delta q = b \\end{aligned} \\label{eq:qp_eq_only} \\end{equation}\\] <p>where</p> \\[\\begin{align} H &amp;=  J_{\\mathrm{com}}^\\top W_{\\mathrm{com}} J_{\\mathrm{com}} + J_{\\mathrm{torso}}^\\top W_{\\mathrm{torso}} J_{\\mathrm{torso}} + J_{\\mathrm{mf}}^\\top W_{\\mathrm{mf}} J_{\\mathrm{mf}} + \\mu I, \\\\[12pt] g &amp;=  - J_{\\mathrm{com}}^\\top W_{\\mathrm{com}} e_{\\mathrm{com}} - J_{\\mathrm{torso}}^\\top W_{\\mathrm{torso}} e_{\\mathrm{torso}} - J_{\\mathrm{mf}}^\\top W_{\\mathrm{mf}} e_{\\mathrm{mf}}, \\end{align}\\] <p>and</p> \\[\\begin{align} A &amp;= J_{ff}  &amp;  b &amp;= e_{ff} \\end{align}\\] <ul> <li>The term \\(\\lambda I\\) provides Tikhonov damping to improve numerical stability</li> </ul> <p>This is solved with <code>qpsolvers.solve_qp</code> (OSQP backend). The solution is then integrated using Pinocchio to compute the  desired joints position.</p>"},{"location":"inverse_kinematics/#example","title":"Example","text":"<p>Inverse kinematics are computed to track CoM and foot trajectories using the Talos model. This produces a full kinematic walking sequence without dynamic simulation.</p> <p>Run the following command:</p> <pre><code>docker run --rm -it -p 7000:7000 \\\n  -p 6000:6000 ghcr.io/rdesarz/biped-walking-controller \\\n  python examples/example_3_walk_inverse_kinematic.py \\\n  --path-talos-data \"/\"\n</code></pre> <p>Then go to the following address in your browser: http://127.0.0.1:7000/static/.</p> <p>The result should look like this:</p> <p> </p>"},{"location":"inverse_kinematics/#references","title":"References","text":"<ul> <li> <p>Caron, S. Jacobian of a kinematic task and derivatives on manifolds.   Available online   at  https://scaron.info/robotics/differential-inverse-kinematics.html,   accessed 2025.   (Detailed explanations and examples for frame kinematics, Jacobian computation, and task-space control using   Pinocchio.)</p> </li> <li> <p>Caron, S. Differential inverse kinematics.   Available online   at https://scaron.info/robotics/jacobians.html,   accessed 2025.   (General introduction to differential inverse kinematics.)</p> </li> <li> <p>Caron, S. Pink: Python inverse kinematics based on Pinocchio    License Apache-2.0    Available at https://github.com/stephane-caron/pink    2025</p> </li> </ul>"},{"location":"inverse_kinematics/#code-api","title":"Code API","text":""},{"location":"inverse_kinematics/#biped_walking_controller.inverse_kinematic.InvKinSolverParams","title":"InvKinSolverParams  <code>dataclass</code>","text":"<pre><code>InvKinSolverParams(fixed_foot_frame, moving_foot_frame, torso_frame, model, data, w_torso, w_com, w_mf, mu, dt, locked_joints=None)\n</code></pre> <p>Parameters for inverse-kinematics QP with CoM, feet, and torso tasks.</p> <p>Attributes:</p> Name Type Description <code>fixed_foot_frame</code> <code>int</code> <p>Pinocchio frame id of the stance foot (hard equality).</p> <code>moving_foot_frame</code> <code>int</code> <p>Pinocchio frame id of the swing foot (soft task).</p> <code>torso_frame</code> <code>int</code> <p>Pinocchio frame id for torso orientation task (angular only).</p> <code>model</code> <code>Model</code> <p>Pinocchio kinematic model.</p> <code>data</code> <code>Any</code> <p>Pinocchio data buffer associated with <code>model</code>.</p> <code>w_torso</code> <code>float</code> <p>Weight of torso angular task in the QP cost.</p> <code>w_com</code> <code>float</code> <p>Weight of CoM task in the QP cost.</p> <code>w_mf</code> <code>float</code> <p>Weight of moving-foot 6D task in the QP cost.</p> <code>mu</code> <code>float</code> <p>Damping on joint velocities in the QP (Tikhonov term).</p> <code>dt</code> <code>float</code> <p>Time step used by caller; not used here directly but kept for API symmetry.</p> <code>locked_joints</code> <code>list[int] | None</code> <p>Optional list of joints or velocity indices to lock. Each element can be:   - a Pinocchio joint id j in [0, model.njoints), which locks its velocity span   - or a direct velocity index v in [0, model.nv)</p>"},{"location":"inverse_kinematics/#biped_walking_controller.inverse_kinematic.solve_inverse_kinematics","title":"solve_inverse_kinematics","text":"<pre><code>solve_inverse_kinematics(q, com_target, oMf_fixed_foot, oMf_moving_foot, oMf_torso, params)\n</code></pre> <p>One-step inverse kinematics via QP with a hard stance-foot constraint.</p> Problem <p>Minimize     w_com || J_com dq - e_com ||^2   + w_torso || J_torso dq - e_torso ||^2   + w_mf || J_mf dq - e_mf ||^2   + mu || dq ||^2 subject to     J_ff dq = e_ff        (fixed-foot 6D equality)</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>(ndarray, shape(nq))</code> <p>Current configuration.</p> required <code>com_target</code> <code>(ndarray, shape(3))</code> <p>Desired CoM position in world.</p> required <code>oMf_fixed_foot</code> <code>SE3</code> <p>Desired world pose of stance foot.</p> required <code>oMf_moving_foot</code> <code>SE3</code> <p>Desired world pose of swing foot.</p> required <code>oMf_torso</code> <code>SE3</code> <p>Desired world pose of torso (only angular part is used).</p> required <code>params</code> <code>InvKinSolverParams</code> <p>Weights, model/data, damping, and optional locked joints.</p> required <p>Returns:</p> Name Type Description <code>q_next</code> <code>(ndarray, shape(nq))</code> <p>Integrated configuration <code>integrate(model, q, dq)</code>.</p> <code>dq</code> <code>(ndarray, shape(nv))</code> <p>Generalized velocity solution (zeros for locked indices).</p> Notes <ul> <li>Builds a reduced QP on active velocity indices if <code>locked_joints</code> is set.</li> <li>CoM task uses Pinocchio <code>jacobianCenterOfMass</code>.</li> <li>Torso task selects angular rows via S = [0 I; 0 0].</li> <li>QP is solved with <code>qpsolvers.solve_qp(..., solver=\"osqp\")</code>.</li> </ul>"},{"location":"preview_control/","title":"Zero-Moment Point (ZMP) Preview Controller","text":""},{"location":"preview_control/#zero-moment-point-and-balance-criterion","title":"Zero Moment Point and Balance Criterion","text":"<p>The Zero Moment Point (ZMP) is the point on the ground where the resultant contact forces between the feet and the ground produce no moment about the horizontal axes. To maintain balance, the ZMP must remain within the robot\u2019s support polygon, defined as the convex hull of the contact areas of the feet. Intuitively, this ensures that the ground reaction forces can generate a counteracting moment to keep the feet flat and prevent tipping, maintaining dynamic equilibrium. For a more thorough explanation I recommend this blog post by St\u00e9phane Caron.</p>"},{"location":"preview_control/#linear-inverted-pendulum-model","title":"Linear Inverted Pendulum Model","text":"<p>The first step of the controller is to define a reference ZMP trajectory, alternating from one foot to the other at each step. This reference is generated using a cubic spline that interpolates the position of each foot.  The objective is to establish a relationship between the position of this reference ZMP and the robot\u2019s Center of Mass ( CoM). This relationship can be derived from a simplified model of the robot\u2019s dynamics known as the Linear Inverted Pendulum Model (LIPM).</p> <p>The LIPM is derived under the following assumptions:</p> <ul> <li>The mass of the body is concentrated at a single point, the Center of Mass (CoM).</li> <li>Legs are massless and do not contribute to the system dynamics.</li> <li>The CoM moves on a horizontal plane at a constant height, eliminating vertical motion coupling.</li> <li>No angular momentum is generated about the CoM, meaning the upper body remains still to avoid producing additional   moments.</li> </ul> <p>Under these assumptions and for small angles, the inverted pendulum dynamics can be linearized, leading to the following second-order linear equation:</p> \\[ \\ddot{x}_c = \\frac{g}{z_c} (x_c - x_z) \\] <p>where \\(x_z\\) denotes the ZMP, \\(x_c\\) the CoM projection, and \\(z_c\\) the constant CoM height.</p>"},{"location":"preview_control/#preview-control","title":"Preview Control","text":"<p>In Kajita's paper, the idea is to use a preview control in order to track and anticipate the ZMP reference change. The control input minimizes a quadratic cost over a finite horizon:</p> \\[ J = \\sum_{k=0}^{\\infty} \\left( Q_e e_k^2 + x_k^T Q_x x_k + R \\Delta u_k^2 \\right) \\] <p>yielding a feedback + integral + preview law. The resulting controller anticipates future ZMP references, ensuring stable walking trajectories.</p> <p>The result of the preview controller can be observed on the figure below. The upper-left figure shows the trajectory of the CoM in red over time, the generated reference ZMP in blue and the support polygon in green. The upper-right and lower-right figures show the trajectory of the ZMP and COM over time for x and y pos. Finally, the lower-left figure shows the preview gains that are computed.</p> <p> </p>"},{"location":"preview_control/#example","title":"Example","text":"<p>You can reproduce the example displayed on the figure by launching the script <code>example_1_lipm_preview_control.py</code>. We recommend you to use Docker as explained in the installation part:</p> <pre><code>xhost +local:root\ndocker run --rm -it \\\n  --env DISPLAY \\\n  -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\\n  --device /dev/dri:/dev/dri \\\n  ghcr.io/rdesarz/biped-walking-controller \\\n  python examples/example_1_lipm_preview_control.py \n</code></pre> <p>The parameters used in this script are the following:</p> <pre><code>dt = 0.005  # Delta of time of the model simulation\nt_preview = 1.6  # Time horizon used for the preview controller\nt_ss = 0.6  # Single support phase time window\nt_ds = 0.4  # Double support phase time window\nt_init = 2.0  # Initialization phase (transition from still position to first step)\nt_end = 1.0  # Final phase (transition from walking to standstill position)\nfoot_shape = Polygon(\n    ((0.11, 0.05), (0.11, -0.05), (-0.11, -0.05), (-0.11, 0.05)))  # Shape of the foot for support polygon computation\nn_steps = 5  # Number of steps\nl_stride = 0.3  # Length of the stride\n</code></pre>"},{"location":"preview_control/#references","title":"References","text":"<ul> <li> <p>Kajita, S., Kanehiro, F., Kaneko, K., Fujiwara, K., Harada, K., Yokoi, K., &amp; Hirukawa, H. Biped Walking Pattern Generation by Using Preview Control of Zero-Moment Point. Proceedings of the IEEE International Conference on Robotics and Automation (ICRA), 2003.</p> </li> <li> <p>Katayama, T., Ohki, T., Inoue, T., &amp; Kato, T. Design of an Optimal Controller for a Discrete-Time System Subject to Previewable Demand. International Journal of Control, vol. 41, no. 3, pp. 677\u2013699, 1985.</p> </li> <li> <p>Caron, S. Zero-tilting moment point.   Available online   at  https://scaron.info/robotics/zero-tilting-moment-point.html,   accessed 2025.   (Detailed explanations and examples for Zero-tilting moment point)</p> </li> </ul>"},{"location":"preview_control/#code-api","title":"Code API","text":"<p>options: members_order: source heading_level: 2</p>"},{"location":"preview_control/#biped_walking_controller.preview_control.PreviewControllerParams","title":"PreviewControllerParams  <code>dataclass</code>","text":"<pre><code>PreviewControllerParams(zc, g, Qe, Qx, R, n_preview_steps)\n</code></pre> <p>Hyperparameters for preview control gain synthesis.</p> <p>Attributes:</p> Name Type Description <code>zc</code> <code>float</code> <p>CoM height (meters).</p> <code>g</code> <code>float</code> <p>Gravity magnitude (m/s^2).</p> <code>Qe</code> <code>(ndarray, shape(1, 1))</code> <p>Weight on integrated ZMP tracking error.</p> <code>Qx</code> <code>(ndarray, shape(3, 3))</code> <p>Weight on state [x, x_dot, x_ddot].</p> <code>R</code> <code>(ndarray, shape(1, 1))</code> <p>Weight on jerk input magnitude.</p> <code>n_preview_steps</code> <code>int</code> <p>Number of preview items P used to build Gd (uses P-1 gains).</p>"},{"location":"preview_control/#biped_walking_controller.preview_control.PreviewControllerMatrices","title":"PreviewControllerMatrices  <code>dataclass</code>","text":"<pre><code>PreviewControllerMatrices(A, B, C, Gi, Gx, Gd)\n</code></pre> <p>Structure that contains the Discrete LIPM-with-jerk preview-control matrices. Serves as input for the update of the control command.</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>(ndarray, shape(3, 3))</code> <p>State transition of [x, x_dot, x_ddot] (per-axis).</p> <code>B</code> <code>(ndarray, shape(3, 1))</code> <p>Input matrix for jerk u.</p> <code>C</code> <code>(ndarray, shape(1, 3))</code> <p>Output mapping from state to ZMP.</p> <code>Gi</code> <code>(float or ndarray, shape(1, 1))</code> <p>Integral gain on ZMP tracking error.</p> <code>Gx</code> <code>(ndarray, shape(1, 4))</code> <p>State-feedback gain on [e_int, x, x_dot, x_ddot].</p> <code>Gd</code> <code>(ndarray, shape(P - 1))</code> <p>Preview gains for future ZMP references over P-1 steps.</p>"},{"location":"preview_control/#biped_walking_controller.preview_control.compute_zmp_ref","title":"compute_zmp_ref","text":"<pre><code>compute_zmp_ref(t, com_initial_pose, steps, ss_t, ds_t, t_init, t_final, interp_fn=cubic_spline_interpolation)\n</code></pre> <p>Build a piecewise ZMP reference on the ground plane from footsteps. The ZMP reference starts at com_initial_pose. Then during t_init period of time, the ZMP shift to the right foot. It then goes from a step to another. Then it goes back between the final position of the feet during t_final.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>(array - like, shape(T))</code> <p>Time samples (seconds), monotonically increasing.</p> required <code>com_initial_pose</code> <code>(array - like, shape(2))</code> <p>Initial ZMP target under the CoM at startup (x, y).</p> required <code>steps</code> <code>(array - like, shape(N, 2))</code> <p>Footstep sequence on the ground (x, y) per step. The last element is the final midpoint target.</p> required <code>ss_t</code> <code>float</code> <p>Duration of single support per step.</p> required <code>ds_t</code> <code>float</code> <p>Duration of double support between steps.</p> required <code>t_init</code> <code>float</code> <p>Ramp time from initial CoM ZMP to the first step.</p> required <code>t_final</code> <code>float</code> <p>Final blending time to bring ZMP to the midpoint of the last two feet.</p> required <p>Returns:</p> Name Type Description <code>zmp_ref</code> <code>(ndarray, shape(T, 2))</code> <p>ZMP reference trajectory on the ground plane.</p> Notes <ul> <li>For each step: hold current foot during SS, then linearly blend to the next   foot during DS.</li> <li>Last phase: SS on the penultimate foot, then blend to the average of the   last two foot positions during <code>t_final</code>.</li> </ul>"},{"location":"preview_control/#biped_walking_controller.preview_control.compute_preview_control_matrices","title":"compute_preview_control_matrices","text":"<pre><code>compute_preview_control_matrices(params, dt)\n</code></pre> <p>Construct preview-control gains for the discrete LIPM with jerk input.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>PreviewControllerParams</code> <p>Model and cost weights.</p> required <code>dt</code> <code>float</code> <p>Discrete time step.</p> required <p>Returns:</p> Type Description <code>PreviewControllerMatrices</code> <p>Controller matrices (A, B, C, Gi, Gx, Gd) reused at runtime.</p> Method <ul> <li>Build augmented system with integral of ZMP error.</li> <li>Solve discrete-time algebraic Riccati equation for K.</li> <li>Derive integral gain Gi, state gain Gx, and preview gains Gd for P-1 future   reference samples using the closed-loop matrix <code>Ac</code>.</li> </ul> References <ul> <li>Kajita et al., 2003. Biped walking pattern generation by using preview control.</li> <li>Katayama et al., 1985. Design of an optimal preview controller.</li> </ul>"},{"location":"preview_control/#biped_walking_controller.preview_control.update_control","title":"update_control","text":"<pre><code>update_control(ctrl_mat, current_zmp, zmp_ref, x, y)\n</code></pre> <p>One-step preview control update for x and y axes.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl_mat</code> <code>PreviewControllerMatrices</code> <p>Precomputed controller matrices.</p> required <code>current_zmp</code> <code>(array - like, shape(2))</code> <p>Measured ZMP at current step [zx, zy].</p> required <code>zmp_ref</code> <code>(ndarray, shape(P - 1, 2))</code> <p>Future ZMP references used with Gd for both axes. First element is the next sample after the current time.</p> required <code>x</code> <code>(ndarray, shape(4))</code> <p>Augmented states per axis: [e_int, pos, vel, acc].</p> required <code>y</code> <code>(ndarray, shape(4))</code> <p>Augmented states per axis: [e_int, pos, vel, acc].</p> required <p>Returns:</p> Name Type Description <code>u</code> <code>(ndarray, shape(2))</code> <p>Jerk command for x and y.</p> <code>x_next, y_next : ndarray, shape (4,)</code> <p>Next augmented states after applying u.</p> Notes <ul> <li>Integral state is updated with ZMP output error, then state is propagated   with (A, B) and jerk input.</li> <li>Uses the same scalar Gi and vector Gx for both axes.</li> </ul>"},{"location":"preview_control/#biped_walking_controller.preview_control.build_zmp_horizon","title":"build_zmp_horizon","text":"<pre><code>build_zmp_horizon(com_initial_target, t_horizon, t_state, state, delta_t, current_step_idx, steps_sequence, steps_foot, ss_t, ds_t, t_init, t_end, interp_fn=cubic_spline_interpolation)\n</code></pre> <p>Build a ZMP reference over a preview horizon based on the current walking state.</p> <p>Parameters:</p> Name Type Description Default <code>t_horizon</code> <code>float</code> <p>Length of the preview horizon [s].</p> required <code>t_state</code> <code>float</code> <p>Time elapsed in the current state [s].</p> required <code>state</code> <code>WalkingState</code> <p>Current walking state (INIT, DS, SS_LEFT, SS_RIGHT, END).</p> required <code>delta_t</code> <code>float</code> <p>Sampling period of the preview horizon [s].</p> required <code>current_step_idx</code> <code>int</code> <p>Index of the current step in <code>steps_sequence</code>. Interpreted as: - In SS: index of the current support foot. - In DS: index of the target foot (previous is current_step_idx - 1).</p> required <code>steps_sequence</code> <code>ndarray</code> <p>Sequence of footsteps. Shape (N, 2) or (N, &gt;=2). Only the (x, y) components are used as ZMP targets.</p> required <code>ss_t</code> <code>float</code> <p>Duration of a single-support phase [s].</p> required <code>ds_t</code> <code>float</code> <p>Duration of a double-support phase [s].</p> required <code>t_init</code> <code>float</code> <p>Duration of the INIT phase [s].</p> required <code>t_end</code> <code>float</code> <p>Duration of the END phase [s].</p> required <code>interp_fn</code> <code>callable</code> <p>Interpolation function used in double support. Expected signature: interp_fn(alpha, p0, p1) where alpha in [0, 1], p0, p1 are 2D numpy arrays.</p> <code>cubic_spline_interpolation</code> <p>Returns:</p> Name Type Description <code>t_samples</code> <code>(ndarray, shape(N))</code> <p>Relative time samples over the horizon, starting at 0.</p> <code>zmp_horizon</code> <code>(ndarray, shape(N, 2))</code> <p>ZMP reference (x, y) at each time sample.</p> Notes <ul> <li>This function does NOT enforce continuity with the previous ZMP reference.   At each call, the horizon is built from scratch from the current state.</li> <li>State-transition logic is a simple cyclic model:   INIT -&gt; DS -&gt; SS -&gt; DS -&gt; SS -&gt; ... -&gt; END   and the step index increments when leaving an SS state.</li> </ul>"},{"location":"simulation/","title":"Integration in physical simulator","text":""},{"location":"simulation/#introduction","title":"Introduction","text":"<p>The simulation module validates the entire walking control pipeline, from ZMP-based pattern generation to joint-space  motion execution. It provides a reproducible environment to test the controller under realistic dynamics. The robot is simulated in PyBullet, which integrates forward dynamics and computes contact forces during each support  phase. The module reproduces the walking sequence defined by the preview controller, including single and double support  phases, ZMP transitions, and foot exchanges. The reference trajectories of the center of mass (CoM) and feet are generated  by the LIPM + preview control model, then projected into joint space through the inverse-kinematics solver based on Pinocchio.</p> <p>At each timestep, the Pinocchio kinematic model is updated using the robot state from PyBullet. The desired joint  positions are then computed and applied through position control, ensuring consistency between the kinematic model and the simulated robot.</p>"},{"location":"simulation/#example","title":"Example","text":"<p>In this example, the controller and inverse-kinematics modules are integrated into PyBullet to test the walking pattern in a simulated environment. The <code>xhost</code> command is only required if you want to display the GUI interface:</p> <pre><code>xhost +local:root\ndocker run --rm -it \\\n  --env DISPLAY \\\n  -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\\n  --device /dev/dri:/dev/dri \\\n  ghcr.io/rdesarz/biped-walking-controller \\\n  python examples/example_4_physics_simulation.py \\\n  --path-talos-data \"/\" --launch-gui --plot-results\n</code></pre> <p>You should get a visualization of the simulation such as the one below:</p> <p> </p> <p>At the end of the walking sequence, a plot should be displayed. It plots the position of the CoM and foot trajectories on x and y axis:</p> <p></p>"},{"location":"simulation/#code-api","title":"Code API","text":"<p>The simulation module provides all components required to initialize and manage the physics simulation. It simplifies  interaction with the robot, including data extraction and joint configuration. The Simulator class currently implements  this interface using PyBullet as the physics backend.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator","title":"Simulator","text":"<pre><code>Simulator(dt, path_to_robot_urdf, model, launch_gui=True, n_solver_iter=200)\n</code></pre> <p>Thin PyBullet wrapper for loading a robot URDF and driving it from joint positions/velocities. Also exposes utilities for camera control, contact-force/ZMP computation, and setter/getter for joints configuration. The robot is loaded at the origin and a flat horizontal plane is added at z=0.</p> <p>Initialize PyBullet, load ground and TALOS, and set physics.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Fixed simulation time step in seconds.</p> required <code>path_to_robot_urdf</code> <code>Path</code> <p>Base path containing the URDF data.</p> required <code>model</code> <code>Any</code> <p>Pinocchio model container used to build pb\u2194pin joint maps. Must expose <code>model</code> for velocity map construction.</p> required <code>launch_gui</code> <code>bool</code> <p>If True, starts PyBullet with GUI. Otherwise uses DIRECT mode.</p> <code>True</code> Side Effects <ul> <li>Connects to PyBullet and configures gravity, time step, and engine params.</li> <li>Loads a plane and the TALOS robot in the world.</li> <li>Builds maps from PyBullet joint indices to Pinocchio q/v indices.</li> </ul>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Advance the physics simulation by one fixed time step.</p> Notes <p>Uses the engine time step configured in <code>__init__</code>.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.reset_robot_configuration","title":"reset_robot_configuration","text":"<pre><code>reset_robot_configuration(q)\n</code></pre> <p>Hard-reset robot state from a configuration vector.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>(ndarray, shape(nq))</code> <p>Full Pinocchio configuration, including free-flyer (7). Applied to PyBullet base + joints via helper mapping.</p> required"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.apply_joints_pos_to_robot","title":"apply_joints_pos_to_robot","text":"<pre><code>apply_joints_pos_to_robot(q)\n</code></pre> <p>Send position targets to PyBullet joint position controllers.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>(ndarray, shape(nq))</code> <p>Desired configuration in Pinocchio ordering.</p> required"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.apply_joints_vel_to_robot","title":"apply_joints_vel_to_robot","text":"<pre><code>apply_joints_vel_to_robot(v)\n</code></pre> <p>Send joint-space velocity targets to the simulator.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(ndarray, shape(nv))</code> <p>Desired generalized velocities in Pinocchio ordering.</p> required"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_q","title":"get_q","text":"<pre><code>get_q(nq)\n</code></pre> <p>Read the current configuration vector from PyBullet.</p> <p>Parameters:</p> Name Type Description Default <code>nq</code> <code>int</code> <p>Total configuration size expected by Pinocchio.</p> required <p>Returns:</p> Type Description <code>(ndarray, shape(nq))</code> <p>Configuration with base pose first (x,y,z, qw,qx,qy,qz), then joints.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.update_camera_to_follow_pos","title":"update_camera_to_follow_pos","text":"<pre><code>update_camera_to_follow_pos(x, y, z)\n</code></pre> <p>Aim the debug camera at a world position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Target position in world frame for the camera to look at.</p> required <code>y</code> <code>float</code> <p>Target position in world frame for the camera to look at.</p> required <code>z</code> <code>float</code> <p>Target position in world frame for the camera to look at.</p> required Notes <p>Keeps distance, yaw, and pitch fixed.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_contact_forces","title":"get_contact_forces","text":"<pre><code>get_contact_forces()\n</code></pre> <p>Return the net x-axis contact forces for the right and left foot.</p> <p>The method queries PyBullet for contacts between the robot and the ground on each foot link, then uses the private helper <code>_compute_force(...)</code> to aggregate the force component along the world x-axis.</p> Requirements <ul> <li><code>self.robot_id</code> : int     PyBullet body id of the robot.</li> <li><code>self.plane_id</code> : int     PyBullet body id of the ground/plane.</li> <li><code>self.rf_link_id</code> : int     Link index of the right foot.</li> <li><code>self.lf_link_id</code> : int     Link index of the left foot.</li> <li><code>_compute_force(contacts) -&gt; tuple[float, Any]</code>     Helper that returns the x-axis force [N] as its first element.     It should return 0.0 if <code>contacts</code> is empty.</li> </ul> <p>Returns:</p> Type Description <code>(float, float)</code> <p><code>(Fx_right, Fx_left)</code> in Newtons, world frame.</p> Notes <ul> <li>Only contacts with <code>bodyA=self.robot_id</code>, <code>bodyB=self.plane_id</code>,   and <code>linkIndexA</code> equal to the corresponding foot link are considered.</li> <li>If a foot has no active contacts, its returned force is expected to be 0.0.</li> <li>This method assumes <code>_compute_force</code> already applies the correct   Newton third-law sign convention to yield the force exerted on the robot.</li> </ul>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.draw_points","title":"draw_points","text":"<pre><code>draw_points(points, colors=None, point_size=5)\n</code></pre> <p>Draw or update a set of debug points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(array - like, shape(N, 3))</code> <p>World coordinates of points.</p> required <code>colors</code> <code>(array - like, shape(N, 3))</code> <p>RGB colors in [0,1] per point.</p> <code>None</code> <code>point_size</code> <code>int</code> <code>5</code> Notes <p>Uses a persistent debug item so updates replace the existing set (for performance reasons)</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_robot_com_position","title":"get_robot_com_position","text":"<pre><code>get_robot_com_position()\n</code></pre> <p>Compute the whole-body center of mass in world coordinates.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>[x, y, z] position of the CoM in the world frame.</p> Method <ul> <li>Retrieves base inertial COM, then iterates articulated links.</li> <li>Mass-weights each link COM and normalizes by total mass.</li> </ul>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_robot_pos","title":"get_robot_pos","text":"<pre><code>get_robot_pos()\n</code></pre> <p>Get the floating base world pose.</p> <p>Returns:</p> Type Description <code>tuple[list[float], list[float]]</code> <p>(position [x,y,z], quaternion [x,y,z,w]) in world frame.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_robot_frame_pos","title":"get_robot_frame_pos","text":"<pre><code>get_robot_frame_pos(frame_name)\n</code></pre> <p>Get world pose of a named link frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_name</code> <code>str</code> <p>Name of the link in the URDF.</p> required <p>Returns:</p> Type Description <code>tuple[tuple[float, float, float], tuple[float, float, float, float]]</code> <p>(position, quaternion) of the link frame in world. Uses PyBullet forward kinematics.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>frame_name</code> is not found.</p>"},{"location":"simulation/#biped_walking_controller.simulation.Simulator.get_zmp_pose","title":"get_zmp_pose","text":"<pre><code>get_zmp_pose()\n</code></pre> <p>Estimate the Zero-Moment Point using contact wrenches against the plane.</p> <p>Returns:</p> Type Description <code>ndarray | None</code> <p>[px, py, 0.0] in world if vertical force Fz != 0, else None.</p> Method <ul> <li>Iterates robot\u2013plane contact points.</li> <li>Accumulates total contact force F and moment M about world origin   using r \u00d7 f at the contact position.</li> <li>ZMP on the ground plane is computed as:   px = -M_y / F_z,  py = M_x / F_z.</li> </ul> Notes <p>This assumes a flat ground at z=0 and uses only normal forces reported by PyBullet at each contact.</p>"}]}